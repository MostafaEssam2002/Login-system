
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Node.js HTTP Module Guide</title>
  <style>
    @page {
      margin: 0.75in;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 100%;
      margin: 0;
      padding: 20px;
    }
    .header {
      background: linear-gradient(135deg, #68b063 0%, #5a9c55 100%);
      color: white;
      padding: 40px 30px;
      margin-bottom: 30px;
      border-radius: 8px;
    }
    .header h1 {
      margin: 0 0 10px 0;
      font-size: 36px;
      font-weight: 700;
    }
    .header p {
      margin: 0;
      font-size: 16px;
      opacity: 0.95;
    }
    h2 {
      color: #68b063;
      font-size: 24px;
      margin-top: 35px;
      margin-bottom: 15px;
      padding-bottom: 8px;
      border-bottom: 3px solid #68b063;
      page-break-after: avoid;
    }
    h3 {
      color: #5a9c55;
      font-size: 18px;
      margin-top: 25px;
      margin-bottom: 12px;
      page-break-after: avoid;
    }
    p {
      margin: 12px 0;
      text-align: justify;
    }
    .code-block {
      background: #f8f9fa;
      border-left: 4px solid #68b063;
      padding: 15px 20px;
      margin: 15px 0;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
      overflow-x: auto;
      white-space: pre;
      page-break-inside: avoid;
    }
    .info-box {
      background: #e8f5e9;
      border: 1px solid #68b063;
      padding: 15px 20px;
      margin: 20px 0;
      border-radius: 6px;
      page-break-inside: avoid;
    }
    .info-box h4 {
      margin: 0 0 10px 0;
      color: #5a9c55;
      font-size: 16px;
    }
    .method-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      page-break-inside: avoid;
    }
    .method-table th {
      background: #68b063;
      color: white;
      padding: 12px;
      text-align: left;
      font-weight: 600;
    }
    .method-table td {
      padding: 10px 12px;
      border-bottom: 1px solid #ddd;
    }
    .method-table tr:nth-child(even) {
      background: #f8f9fa;
    }
    ul {
      margin: 10px 0;
      padding-left: 25px;
    }
    li {
      margin: 8px 0;
    }
    .footer {
      margin-top: 50px;
      padding-top: 20px;
      border-top: 2px solid #ddd;
      text-align: center;
      color: #666;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Node.js HTTP Module</h1>
    <p>A Comprehensive Guide to Building HTTP Servers and Clients</p>
  </div>

  <h2>Introduction</h2>
  <p>
    The HTTP module is a core module in Node.js that enables developers to create HTTP servers and clients. 
    It provides the fundamental building blocks for web applications, allowing you to handle HTTP requests 
    and responses without requiring external dependencies. This module is essential for building web servers, 
    RESTful APIs, and making HTTP requests to external services.
  </p>

  <h2>Getting Started</h2>
  <p>
    Since HTTP is a core module, you don't need to install it separately. Simply require it in your Node.js application:
  </p>
  <div class="code-block">const http = require('http');</div>

  <h2>Creating an HTTP Server</h2>
  <p>
    The most common use case for the HTTP module is creating a web server. Here's a basic example:
  </p>
  <div class="code-block">const http = require('http');

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World!');
});

server.listen(3000, () => {
  console.log('Server running at http://localhost:3000/');
});</div>

  <h3>Request Object (req)</h3>
  <p>
    The request object contains information about the incoming HTTP request. Key properties include:
  </p>
  <table class="method-table">
    <thead>
      <tr>
        <th>Property</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>req.method</td>
        <td>HTTP method (GET, POST, PUT, DELETE, etc.)</td>
      </tr>
      <tr>
        <td>req.url</td>
        <td>Request URL path</td>
      </tr>
      <tr>
        <td>req.headers</td>
        <td>Object containing request headers</td>
      </tr>
      <tr>
        <td>req.httpVersion</td>
        <td>HTTP version of the request</td>
      </tr>
    </tbody>
  </table>

  <h3>Response Object (res)</h3>
  <p>
    The response object is used to send data back to the client. Important methods include:
  </p>
  <table class="method-table">
    <thead>
      <tr>
        <th>Method</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>res.statusCode</td>
        <td>Set the HTTP status code</td>
      </tr>
      <tr>
        <td>res.setHeader()</td>
        <td>Set a single header value</td>
      </tr>
      <tr>
        <td>res.writeHead()</td>
        <td>Write status code and headers</td>
      </tr>
      <tr>
        <td>res.write()</td>
        <td>Write data to the response body</td>
      </tr>
      <tr>
        <td>res.end()</td>
        <td>End the response (required)</td>
      </tr>
    </tbody>
  </table>

  <h2>Handling Different Routes</h2>
  <p>
    You can handle different routes by checking the request URL and method:
  </p>
  <div class="code-block">const server = http.createServer((req, res) => {
  if (req.url === '/' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end('<h1>Home Page</h1>');
  } else if (req.url === '/about' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end('<h1>About Page</h1>');
  } else {
    res.writeHead(404, { 'Content-Type': 'text/html' });
    res.end('<h1>404 Not Found</h1>');
  }
});</div>

  <h2>Handling POST Requests</h2>
  <p>
    To handle POST data, you need to listen for data events on the request object:
  </p>
  <div class="code-block">const server = http.createServer((req, res) => {
  if (req.method === 'POST') {
    let body = '';
    
    req.on('data', chunk => {
      body += chunk.toString();
    });
    
    req.on('end', () => {
      console.log('Received data:', body);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ message: 'Data received' }));
    });
  }
});</div>

  <h2>Making HTTP Requests</h2>
  <p>
    The HTTP module also allows you to make outgoing HTTP requests to external services:
  </p>
  <div class="code-block">const http = require('http');

const options = {
  hostname: 'api.example.com',
  port: 80,
  path: '/data',
  method: 'GET'
};

const req = http.request(options, (res) => {
  let data = '';
  
  res.on('data', (chunk) => {
    data += chunk;
  });
  
  res.on('end', () => {
    console.log('Response:', data);
  });
});

req.on('error', (error) => {
  console.error('Error:', error);
});

req.end();</div>

  <div class="info-box">
    <h4>ðŸ’¡ HTTP vs HTTPS</h4>
    <p>
      For HTTPS connections, use the <strong>https</strong> module instead. It works similarly 
      to the HTTP module but provides secure encrypted connections. Simply replace 
      <code>require('http')</code> with <code>require('https')</code>.
    </p>
  </div>

  <h2>Common HTTP Status Codes</h2>
  <table class="method-table">
    <thead>
      <tr>
        <th>Code</th>
        <th>Message</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>200</td>
        <td>OK</td>
        <td>Request successful</td>
      </tr>
      <tr>
        <td>201</td>
        <td>Created</td>
        <td>Resource created successfully</td>
      </tr>
      <tr>
        <td>400</td>
        <td>Bad Request</td>
        <td>Invalid request syntax</td>
      </tr>
      <tr>
        <td>404</td>
        <td>Not Found</td>
        <td>Resource not found</td>
      </tr>
      <tr>
        <td>500</td>
        <td>Internal Server Error</td>
        <td>Server encountered an error</td>
      </tr>
    </tbody>
  </table>

  <h2>Best Practices</h2>
  <ul>
    <li>Always call <code>res.end()</code> to properly close the response</li>
    <li>Set appropriate Content-Type headers for your responses</li>
    <li>Handle errors using error event listeners</li>
    <li>Use appropriate HTTP status codes for different scenarios</li>
    <li>Consider using frameworks like Express.js for production applications</li>
    <li>Implement proper error handling and logging</li>
    <li>Use environment variables for configuration (ports, hosts, etc.)</li>
  </ul>

  <div class="info-box">
    <h4>âš¡ Performance Tip</h4>
    <p>
      For production applications, consider using frameworks like <strong>Express.js</strong> or 
      <strong>Fastify</strong> which are built on top of the HTTP module and provide additional 
      features like middleware, routing, and better error handling.
    </p>
  </div>

  <h2>Server Events</h2>
  <p>
    The HTTP server emits several events that you can listen to:
  </p>
  <div class="code-block">const server = http.createServer();

server.on('request', (req, res) => {
  // Handle request
});

server.on('connection', (socket) => {
  console.log('New connection established');
});

server.on('close', () => {
  console.log('Server closed');
});

server.listen(3000);</div>

  <h2>Conclusion</h2>
  <p>
    The Node.js HTTP module is a powerful and flexible tool for building web servers and making 
    HTTP requests. While it's suitable for learning and simple applications, production applications 
    typically benefit from higher-level frameworks that provide additional features and abstractions. 
    Understanding the HTTP module gives you a solid foundation for working with any Node.js web framework.
  </p>

  <div class="footer">
    <p>Node.js HTTP Module Guide â€¢ Generated on 11/7/2025</p>
  </div>
</body>
</html>
